// Generated by CoffeeScript 1.12.3
(function() {
  var Fairy, Queue, Worker, callbacks, cluster, create_client, domain, error, os, prefix, pubsub_clients, redis, server_ip, shut_down, shutting_down, uuid, version, workers,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  redis = require('redis');

  uuid = require('node-uuid');

  os = require('os');

  domain = require('domain');

  cluster = require('cluster');

  prefix = 'FAIRY';

  workers = [];

  callbacks = {};

  shutting_down = false;

  error = false;

  version = require('../package.json').version;

  module.exports = {
    version: version,
    connect: function(options) {
      if (options == null) {
        options = {};
      }
      return new Fairy(options);
    }
  };

  shut_down = function(signo) {
    var id, ref, waiting_to_exit, worker;
    if (signo == null) {
      signo = 'SIGTERM';
    }
    ref = cluster.workers || {};
    for (id in ref) {
      worker = ref[id];
      worker.suicide = true;
      worker.process.kill(signo);
    }
    if (shutting_down) {
      return workers.filter(function(arg) {
        var task;
        task = arg.task;
        return task;
      }).forEach(function(worker) {
        return worker.shut_down(true);
      });
    }
    shutting_down = true;
    workers.filter(function(arg) {
      var idle;
      idle = arg.idle;
      return idle;
    }).forEach(function(worker) {
      return worker.shut_down(true);
    });
    return (waiting_to_exit = function() {
      if (workers.length || Object.keys(cluster.workers || {}).length) {
        return setTimeout(waiting_to_exit, 10);
      }
      return process.exit(error ? 1 : 0);
    })();
  };

  ['SIGINT', 'SIGHUP', 'SIGQUIT', 'SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGABRT'].forEach(function(signo) {
    return process.on(signo, shut_down.bind(this, signo));
  });

  process.on('uncaughtException', function(err) {
    console.error(err.stack);
    error = true;
    return shut_down();
  });

  server_ip = function() {
    var address, addresses, card, j, len, ref, ref1;
    ref = os.networkInterfaces();
    for (card in ref) {
      addresses = ref[card];
      for (j = 0, len = addresses.length; j < len; j++) {
        address = addresses[j];
        if (((ref1 = address.family) === 'IPv4') && !address.internal) {
          return address.address;
        }
      }
    }
    return 'N/A';
  };

  pubsub_clients = {};

  create_client = function(options, pubsub) {
    var channels, client, index;
    if (pubsub) {
      index = options.port + "|" + options.host;
      if (client = pubsub_clients[index]) {
        return client;
      }
    }
    client = redis.createClient(options.port | 6379, options.host, options.options);
    if (options.password) {
      client.auth(options.password);
    }
    if (pubsub) {
      pubsub_clients[index] = client;
      channels = ['FAIRY:COMPLETE', 'FAIRY:PROGRESS'];
      client.subscribe.apply(client, channels);
      client.on('message', function(channel, message) {
        var ref, ref1, ref2, task_id;
        if (indexOf.call(channels, channel) < 0) {
          return;
        }
        message = JSON.parse("" + message);
        ref = message, task_id = ref[0], message = ref[1];
        switch (channel) {
          case 'FAIRY:COMPLETE':
            if ((ref1 = callbacks[task_id]) != null) {
              if (typeof ref1.complete === "function") {
                ref1.complete(message);
              }
            }
            return delete callbacks[task_id];
          case 'FAIRY:PROGRESS':
            return (ref2 = callbacks[task_id]) != null ? typeof ref2.progress === "function" ? ref2.progress(message) : void 0 : void 0;
        }
      });
    }
    return client;
  };

  Fairy = (function() {
    function Fairy(options1) {
      this.options = options1;
      this.statistics = bind(this.statistics, this);
      this.queues = bind(this.queues, this);
      this.id = uuid.v4();
      this.redis = create_client(options);
      this.pubsub = create_client(options, true);
      this.queue_pool = {};
    }

    Fairy.prototype.key = function(key) {
      return prefix + ":" + key;
    };

    Fairy.prototype.queue = function(name) {
      if (this.queue_pool[name]) {
        return this.queue_pool[name];
      }
      this.redis.sadd(this.key('QUEUES'), name);
      return this.queue_pool[name] = new Queue(this, name);
    };

    Fairy.prototype.queues = function(callback) {
      return this.redis.smembers(this.key('QUEUES'), (function(_this) {
        return function(err, res) {
          if (err) {
            return callback(err);
          }
          return callback(null, res.map(function(name) {
            return _this.queue(name);
          }));
        };
      })(this));
    };

    Fairy.prototype.statistics = function(callback) {
      return this.queues(function(err, queues) {
        var i, j, len, queue, result, results, total_queues;
        if (err) {
          return callback(err);
        }
        if (!(total_queues = queues.length)) {
          return callback(null, []);
        }
        result = [];
        results = [];
        for (i = j = 0, len = queues.length; j < len; i = ++j) {
          queue = queues[i];
          results.push((function(queue, i) {
            return queue.statistics(function(err, statistics) {
              if (err) {
                return callback(err);
              }
              result[i] = statistics;
              if (!--total_queues) {
                if (callback) {
                  return callback(null, result);
                }
              }
            });
          })(queue, i));
        }
        return results;
      });
    };

    return Fairy;

  })();

  Queue = (function() {
    function Queue(fairy1, name1) {
      this.fairy = fairy1;
      this.name = name1;
      this.workers = bind(this.workers, this);
      this.failed_tasks = bind(this.failed_tasks, this);
      this.recently_finished_tasks = bind(this.recently_finished_tasks, this);
      this.pending_tasks = bind(this.pending_tasks, this);
      this.pending_groups = bind(this.pending_groups, this);
      this.ignore_failed_tasks = bind(this.ignore_failed_tasks, this);
      this.clear = bind(this.clear, this);
      this.retry = bind(this.retry, this);
      this.regist = bind(this.regist, this);
      this.enqueue = bind(this.enqueue, this);
      this.redis = fairy.redis, this.pubsub = fairy.pubsub;
    }

    Queue.prototype.key = function(key) {
      return prefix + ":" + key + ":" + this.name;
    };

    Queue.prototype.enqueue = function(group) {
      var args, callback_complete, callback_enqueued, callback_progress, i, j, original_arguments, ref, ref1, ref2, ref3, ref4, task_id;
      original_arguments = Array.prototype.slice.call(arguments);
      for (i = j = 0, ref = arguments.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if ((ref1 = typeof arguments[i]) === 'function') {
          break;
        }
      }
      if ((ref2 = typeof arguments[i + 0]) === 'function') {
        callback_enqueued = arguments[i + 0];
        args = original_arguments.slice(1, i);
      } else {
        args = original_arguments.slice(1, arguments.length);
      }
      if ((ref3 = typeof arguments[i + 1]) === 'function') {
        callback_complete = arguments[i + 1];
      }
      if ((ref4 = typeof arguments[i + 2]) === 'function') {
        callback_progress = arguments[i + 2];
      }
      task_id = uuid.v4();
      callbacks[task_id] = {
        complete: callback_complete,
        progress: callback_progress
      };
      return this.redis.multi().rpush(this.key('SOURCE'), JSON.stringify([task_id, group].concat(slice.call(args), [Date.now()]))).sadd(this.key('GROUPS'), "" + (JSON.stringify(group))).hincrby(this.key('STATISTICS'), 'TOTAL', 1).publish(this.key('ENQUEUED'), '').exec(callback_enqueued);
    };

    Queue.prototype.regist = function(handler) {
      return workers.push(new Worker(this, handler));
    };

    Queue.prototype.retry = function(callback) {
      var client, retry;
      client = create_client(this.fairy.options);
      return (retry = (function(_this) {
        return function() {
          client.watch(_this.key('FAILED'));
          client.watch(_this.key('SOURCE'));
          client.watch(_this.key('BLOCKED'));
          client.watch(_this.key('PROCESSING'));
          return client.hlen(_this.key('PROCESSING'), function(err, res) {
            return _this.failed_tasks(function(err, tasks) {
              var requeued_tasks;
              requeued_tasks = [];
              requeued_tasks.push.apply(requeued_tasks, tasks.map(function(task) {
                return JSON.stringify([task.id].concat(slice.call(task.params), [task.queued.valueOf()]));
              }));
              return _this.blocked_groups(function(err, groups) {
                var group, j, len, results, start_transaction, total_groups;
                if (groups.length) {
                  client.watch.apply(client, groups.map(function(group) {
                    return (_this.key('QUEUED')) + ":" + group;
                  }));
                }
                start_transaction = function() {
                  var multi;
                  multi = client.multi();
                  if (requeued_tasks.length) {
                    multi.lpush.apply(multi, [_this.key('SOURCE')].concat(slice.call(requeued_tasks.reverse())));
                  }
                  multi.del(_this.key('FAILED'));
                  if (groups.length) {
                    multi.del.apply(multi, groups.map(function(group) {
                      return (_this.key('QUEUED')) + ":" + group;
                    }));
                  }
                  multi.del(_this.key('BLOCKED'));
                  return multi.exec(function(multi_err, multi_res) {
                    if (multi_err) {
                      client.quit();
                      return callback(multi_err);
                    }
                    if (multi_res) {
                      client.quit();
                      _this.redis.publish(_this.key('ENQUEUED'), "");
                      return _this.statistics(callback);
                    } else {
                      return retry(callback);
                    }
                  });
                };
                if (total_groups = groups.length) {
                  results = [];
                  for (j = 0, len = groups.length; j < len; j++) {
                    group = groups[j];
                    results.push(client.lrange((_this.key('QUEUED')) + ":" + group, 1, -1, function(err, res) {
                      requeued_tasks.push.apply(requeued_tasks, res);
                      if (!--total_groups) {
                        return start_transaction();
                      }
                    }));
                  }
                  return results;
                } else {
                  return start_transaction();
                }
              });
            });
          });
        };
      })(this))();
    };

    Queue.prototype.clear = function(callback) {
      this.redis.watch(this.key('SOURCE'));
      this.redis.watch(this.key('PROCESSING'));
      return this.redis.hlen(this.key('PROCESSING'), (function(_this) {
        return function(err, processing) {
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          return _this.redis.keys((_this.key('QUEUED')) + ":*", function(err, res) {
            var ref;
            if (err) {
              return typeof callback === "function" ? callback(err) : void 0;
            }
            return (ref = _this.redis.multi()).del.apply(ref, [_this.key('GROUPS'), _this.key('RECENT'), _this.key('FAILED'), _this.key('SOURCE'), _this.key('STATISTICS'), _this.key('SLOWEST'), _this.key('BLOCKED'), _this.key('GROUPS:FINISHED'), _this.key('GROUPS:FAILED')].concat(slice.call(res))).hmset(_this.key('STATISTICS'), 'TOTAL', processing, 'FINISHED', 0, 'TOTAL_PENDING_TIME', 0, 'TOTAL_PROCESS_TIME', 0).exec(function(err, res) {
              if (err) {
                return typeof callback === "function" ? callback(err) : void 0;
              }
              if (!res) {
                return _this.clear(callback);
              }
              if (callback) {
                return _this.statistics(callback);
              }
            });
          });
        };
      })(this));
    };

    Queue.prototype.ignore_failed_tasks = function(callback) {
      var client, retry;
      client = create_client(this.fairy.options);
      return (retry = (function(_this) {
        return function() {
          client.watch(_this.key('FAILED'));
          client.watch(_this.key('SOURCE'));
          client.watch(_this.key('BLOCKED'));
          client.watch(_this.key('PROCESSING'));
          return client.hlen(_this.key('PROCESSING'), function(err, res) {
            var requeued_tasks;
            requeued_tasks = [];
            return _this.blocked_groups(function(err, groups) {
              var group, j, len, results, start_transaction, total_groups;
              if (groups.length) {
                client.watch.apply(client, groups.map(function(group) {
                  return (_this.key('QUEUED')) + ":" + group;
                }));
              }
              start_transaction = function() {
                var multi;
                multi = client.multi();
                multi.llen(_this.key('FAILED'));
                if (requeued_tasks.length) {
                  multi.lpush.apply(multi, [_this.key('SOURCE')].concat(slice.call(requeued_tasks.reverse())));
                }
                multi.del(_this.key('FAILED'));
                multi.del(_this.key('GROUPS:FAILED'));
                if (groups.length) {
                  multi.del.apply(multi, groups.map(function(group) {
                    return (_this.key('QUEUED')) + ":" + group;
                  }));
                }
                multi.del(_this.key('BLOCKED'));
                return multi.exec(function(multi_err, multi_res) {
                  if (multi_err) {
                    client.quit();
                    return callback(multi_err);
                  }
                  if (multi_res) {
                    client.hincrby(_this.key('STATISTICS'), 'IGNORED', multi_res[0]);
                    client.quit();
                    _this.redis.publish(_this.key('ENQUEUED'), "");
                    return _this.statistics(callback);
                  } else {
                    return retry(callback);
                  }
                });
              };
              if (total_groups = groups.length) {
                results = [];
                for (j = 0, len = groups.length; j < len; j++) {
                  group = groups[j];
                  results.push(client.lrange((_this.key('QUEUED')) + ":" + group, 1, -1, function(err, res) {
                    requeued_tasks.push.apply(requeued_tasks, res);
                    if (!--total_groups) {
                      return start_transaction();
                    }
                  }));
                }
                return results;
              } else {
                return start_transaction();
              }
            });
          });
        };
      })(this))();
    };

    Queue.prototype.pending_groups = function(callback) {
      return this.pending_tasks((function(_this) {
        return function(err, pending_tasks) {
          var groups, j, len, pending_task;
          if (err) {
            return callback(err);
          }
          groups = {};
          for (j = 0, len = pending_tasks.length; j < len; j++) {
            pending_task = pending_tasks[j];
            groups[JSON.stringify(pending_task.params[0])] = 1;
          }
          return callback(null, Object.keys(groups));
        };
      })(this));
    };

    Queue.prototype.pending_tasks = function(callback) {
      return this.redis.multi().smembers(this.key('GROUPS')).lrange(this.key('SOURCE'), 0, -1).exec((function(_this) {
        return function(multi_err, multi_res) {
          var group, j, len, multi2, pending_tasks, ref;
          if (multi_err) {
            return callback(multi_err);
          }
          pending_tasks = multi_res[1].map(function(entry) {
            entry = JSON.parse(entry);
            return {
              id: entry[0],
              params: entry.slice(1, -1),
              queued: new Date(entry.pop())
            };
          });
          multi2 = _this.redis.multi();
          ref = multi_res[0];
          for (j = 0, len = ref.length; j < len; j++) {
            group = ref[j];
            multi2.lrange((_this.key('QUEUED')) + ":" + group, 1, -1);
          }
          return multi2.exec(function(multi2_err, multi2_res) {
            if (multi2_err) {
              return callback(multi2_err);
            }
            return callback(null, pending_tasks.concat(multi2_res.reduce((function(memo, queued) {
              return memo.concat(queued);
            }), []).map(function(entry) {
              entry = JSON.parse(entry);
              return {
                id: entry[0],
                params: entry.slice(1, -1),
                queued: new Date(entry.pop())
              };
            })));
          });
        };
      })(this));
    };

    Queue.prototype.recently_finished_tasks = function(after, callback) {
      var ref;
      if ((ref = typeof after) === 'function') {
        callback = after;
        after = void 0;
      }
      return this.redis.lrange(this.key('RECENT'), 0, -1, function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = JSON.parse(entry);
          return {
            id: entry[0],
            params: entry.slice(1, -3),
            finished: new Date(entry.pop()),
            start: new Date(entry.pop()),
            queued: new Date(entry.pop())
          };
        }).filter(function(arg) {
          var finished;
          finished = arg.finished;
          return !after || finished >= after;
        }));
      });
    };

    Queue.prototype.failed_tasks = function(after, callback) {
      var ref;
      if ((ref = typeof after) === 'function') {
        callback = after;
        after = void 0;
      }
      return this.redis.lrange(this.key('FAILED'), 0, -1, function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = JSON.parse(entry);
          return {
            id: entry[0],
            params: entry.slice(1, -4),
            reason: entry.pop(),
            failed: new Date(entry.pop()),
            start: new Date(entry.pop()),
            queued: new Date(entry.pop())
          };
        }).filter(function(arg) {
          var failed;
          failed = arg.failed;
          return !after || failed >= after;
        }));
      });
    };

    Queue.prototype.blocked_groups = function(callback) {
      return this.redis.smembers(this.key('BLOCKED'), function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          return entry;
        }));
      });
    };

    Queue.prototype.slowest_tasks = function(callback) {
      return this.redis.zrevrange(this.key('SLOWEST'), 0, -1, "WITHSCORES", function(err, res) {
        var i;
        if (err) {
          return callback(err);
        }
        res = res.map(function(entry) {
          return JSON.parse(entry);
        });
        return callback(null, ((function() {
          var j, ref, results;
          results = [];
          for (i = j = 0, ref = res.length; j < ref; i = j += 2) {
            results.push(slice.call(res[i]).concat([res[i + 1]]));
          }
          return results;
        })()).map(function(entry) {
          return {
            id: entry[0],
            params: entry.slice(1, -3),
            time: entry.pop(),
            started: new Date(entry.pop()),
            queued: new Date(entry.pop())
          };
        }));
      });
    };

    Queue.prototype.processing_tasks = function(callback) {
      return this.redis.hvals(this.key('PROCESSING'), function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = JSON.parse(entry);
          return {
            id: entry[0],
            params: entry.slice(1, -2),
            start: new Date(entry.pop()),
            queued: new Date(entry.pop())
          };
        }));
      });
    };

    Queue.prototype.source_tasks = function() {
      var args, callback, j, skip, take;
      args = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), callback = arguments[j++];
      skip = args[0] || 0;
      take = args[1] || 10;
      return this.redis.lrange(this.key('SOURCE'), skip, skip + take - 1, function(err, res) {
        if (err) {
          callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = JSON.parse(entry);
          return {
            id: entry[0],
            params: entry.slice(1, -1),
            queued: new Date(entry.pop())
          };
        }));
      });
    };

    Queue.prototype.workers = function(callback) {
      return this.redis.hvals(this.key('WORKERS'), function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = entry.split('|');
          return {
            version: entry[0],
            host: entry[1],
            ip: entry[2],
            pid: parseInt(entry[3]),
            since: new Date(parseInt(entry[4]))
          };
        }).sort(function(a, b) {
          if (a.ip > b.ip) {
            return 1;
          }
          if (a.ip < b.ip) {
            return -1;
          }
          if (a.pid > b.pid) {
            return 1;
          }
          if (a.pid < b.pid) {
            return -1;
          }
        }));
      });
    };

    Queue.prototype.statistics = function(callback) {
      return this.redis.multi().scard(this.key('GROUPS')).hgetall(this.key('STATISTICS')).hlen(this.key('PROCESSING')).llen(this.key('FAILED')).smembers(this.key('BLOCKED')).hlen(this.key('WORKERS')).scard(this.key('GROUPS:FINISHED')).scard(this.key('GROUPS:FAILED')).exec((function(_this) {
        return function(multi_err, multi_res) {
          var group, j, len, multi2, ref, result, statistics;
          if (multi_err) {
            return callback(multi_err);
          }
          statistics = multi_res[1] || {};
          result = {
            name: _this.name,
            total: {
              groups: multi_res[0],
              tasks: parseInt(statistics.TOTAL) || 0
            },
            finished: {
              groups: multi_res[6],
              tasks: parseInt(statistics.FINISHED) || 0
            },
            ignored: {
              groups: 0,
              tasks: parseInt(statistics.IGNORED) || 0
            },
            average_pending_time: Math.round(statistics.TOTAL_PENDING_TIME * 100 / statistics.FINISHED) / 100,
            averageprocess_time: Math.round(statistics.TOTAL_PROCESS_TIME * 100 / statistics.FINISHED) / 100,
            blocked: {
              groups: multi_res[4].length
            },
            processing_tasks: multi_res[2],
            failed: {
              groups: multi_res[7],
              tasks: multi_res[3]
            },
            pending: {},
            workers: multi_res[5]
          };
          if (result.finished.tasks === 0) {
            result.average_pending_time = '-';
            result.averageprocess_time = '-';
          }
          multi2 = _this.redis.multi();
          ref = multi_res[4];
          for (j = 0, len = ref.length; j < len; j++) {
            group = ref[j];
            multi2.llen((_this.key('QUEUED')) + ":" + group);
          }
          return multi2.exec(function(multi2_err, multi2_res) {
            if (multi2_err) {
              return callback(multi2_err);
            }
            result.blocked.tasks = multi2_res.reduce((function(a, b) {
              return a + b;
            }), -result.blocked.groups);
            result.pending.tasks = result.total.tasks - result.finished.tasks - result.processing_tasks - result.failed.tasks - result.blocked.tasks - result.ignored.tasks;
            return _this.pending_groups(function(err, pending_groups) {
              if (err) {
                return callback(err);
              }
              result.pending.groups = pending_groups.length;
              return callback(null, result);
            });
          });
        };
      })(this));
    };

    return Queue;

  })();

  Worker = (function() {
    Worker.prototype.retry_limit = 2;

    Worker.prototype.retry_delay = 0;

    Worker.prototype.recent_size = 100000;

    Worker.prototype.slowest_size = 10000;

    function Worker(queue1, handler1) {
      this.queue = queue1;
      this.handler = handler1;
      this.continue_group = bind(this.continue_group, this);
      this.process = bind(this.process, this);
      this.start = bind(this.start, this);
      this.name = queue.name, this.fairy = queue.fairy, this.redis = queue.redis, this.pubsub = queue.pubsub;
      this.id = uuid.v4();
      this.redis.hset(this.key('WORKERS'), this.id, version + "|" + (os.hostname()) + "|" + (server_ip()) + "|" + process.pid + "|" + (Date.now()));
      this.pubsub.subscribe(this.key('ENQUEUED'));
      this.pubsub.on('message', (function(_this) {
        return function(channel, message) {
          if (channel !== _this.key('ENQUEUED')) {
            return;
          }
          if (_this.idle) {
            return _this.start();
          }
        };
      })(this));
      this.idle = true;
      this.start();
    }

    Worker.prototype.key = function(key) {
      return prefix + ":" + key + ":" + this.name;
    };

    Worker.prototype.start = function() {
      if (shutting_down || error) {
        return this.shut_down();
      }
      this.idle = false;
      this.redis.watch(this.key('SOURCE'));
      return this.redis.lindex(this.key('SOURCE'), 0, (function(_this) {
        return function(err, res) {
          var task;
          if (task = JSON.parse(res)) {
            return _this.redis.multi().lpop(_this.key('SOURCE')).rpush((_this.key('QUEUED')) + ":" + task[1], res).exec(function(multi_err, multi_res) {
              if ((multi_res != null ? multi_res[1] : void 0) !== 1) {
                return _this.start();
              }
              return _this.process(task);
            });
          } else {
            _this.redis.unwatch();
            return _this.idle = true;
          }
        };
      })(this));
    };

    Worker.prototype.process = function(task1) {
      var errors, handler_callback, process_task, retry_count;
      this.task = task1;
      this.redis.hset(this.key('PROCESSING'), this.id, JSON.stringify(slice.call(task).concat([task.start_time = Date.now()])));
      retry_count = this.retry_limit;
      errors = [];
      handler_callback = (function(_this) {
        return function(err, res) {
          var finish_time, process_time;
          delete _this.task;
          if (_this.shutting_down) {
            return;
          }
          if (err) {
            errors.push(err.message || null);
            switch (err["do"]) {
              case 'block':
                _this.redis.multi().rpush(_this.key('FAILED'), JSON.stringify(slice.call(task).concat([task.start_time], [Date.now()], [errors]))).sadd(_this.key('GROUPS:FAILED'), task[1]).hdel(_this.key('PROCESSING'), _this.id).sadd(_this.key('BLOCKED'), task[1]).exec();
                return _this.start();
              case 'block-after-retry':
                if (retry_count--) {
                  return setTimeout(process_task, _this.retry_delay);
                }
                _this.redis.multi().rpush(_this.key('FAILED'), JSON.stringify(slice.call(task).concat([task.start_time], [Date.now()], [errors]))).sadd(_this.key('GROUPS:FAILED'), task[1]).hdel(_this.key('PROCESSING'), _this.id).sadd(_this.key('BLOCKED'), task[1]).exec();
                return _this.start();
              default:
                if (retry_count--) {
                  return setTimeout(process_task, _this.retry_delay);
                }
                _this.redis.multi().rpush(_this.key('FAILED'), JSON.stringify(slice.call(task).concat([task.start_time], [Date.now()], [errors]))).sadd(_this.key('GROUPS:FAILED'), task[1]).hdel(_this.key('PROCESSING'), _this.id).exec();
            }
          } else {
            finish_time = Date.now();
            process_time = finish_time - task.start_time;
            _this.redis.multi().hdel(_this.key('PROCESSING'), _this.id).hincrby(_this.key('STATISTICS'), 'FINISHED', 1).sadd(_this.key('GROUPS:FINISHED'), task[1]).hincrby(_this.key('STATISTICS'), 'TOTAL_PENDING_TIME', task.start_time - task[task.length - 1]).hincrby(_this.key('STATISTICS'), 'TOTAL_PROCESS_TIME', process_time).lpush(_this.key('RECENT'), JSON.stringify(slice.call(task).concat([task.start_time], [finish_time]))).ltrim(_this.key('RECENT'), 0, _this.recent_size - 1).zadd(_this.key('SLOWEST'), process_time, JSON.stringify(slice.call(task).concat([task.start_time]))).zremrangebyrank(_this.key('SLOWEST'), 0, -_this.slowest_size - 1).publish('FAIRY:COMPLETE', JSON.stringify([task[0], res])).exec();
          }
          return _this.continue_group(task[1]);
        };
      })(this);
      return (process_task = (function(_this) {
        return function() {
          var d;
          d = domain.create();
          d.on('error', function(error) {
            error = true;
            console.error(error.stack);
            return handler_callback({
              "do": 'block',
              message: error.stack
            });
          });
          return d.run(function() {
            return _this.handler.apply(_this, slice.call(task.slice(1, -1)).concat([handler_callback], [function(progress) {
              return _this.redis.publish('FAIRY:PROGRESS', JSON.stringify([task[0], progress]));
            }]));
          });
        };
      })(this))();
    };

    Worker.prototype.continue_group = function(group) {
      this.redis.watch((this.key('QUEUED')) + ":" + group);
      return this.redis.lindex((this.key('QUEUED')) + ":" + group, 1, (function(_this) {
        return function(err, res) {
          var task;
          if (task = JSON.parse(res)) {
            if (shutting_down) {
              return _this.redis.lrange((_this.key('QUEUED')) + ":" + group, 1, -1, function(err, res) {
                var ref;
                return (ref = _this.redis.multi().lpop((_this.key('QUEUED')) + ":" + group)).lpush.apply(ref, ["" + (_this.key('SOURCE'))].concat(slice.call(res.reverse()))).del((_this.key('QUEUED')) + ":" + group).exec(function(multi_err, multi_res) {
                  if (!multi_res) {
                    return _this.continue_group(group);
                  }
                  return _this.start();
                });
              });
            } else {
              _this.redis.unwatch();
              _this.redis.lpop((_this.key('QUEUED')) + ":" + group);
              return _this.process(task);
            }
          } else {
            return _this.redis.multi().lpop((_this.key('QUEUED')) + ":" + group).exec(function(multi_err, multi_res) {
              if (!multi_res) {
                return _this.continue_group(group);
              }
              return _this.start();
            });
          }
        };
      })(this));
    };

    Worker.prototype.shut_down = function(do_not_bubble) {
      if (this.shutting_down) {
        return;
      }
      this.shutting_down = true;
      if (this.task) {
        this.redis.hdel(this.key('PROCESSING'), this.id);
        this.redis.rpush(this.key('FAILED'), JSON.stringify(slice.call(this.task).concat([this.task.start_time], [Date.now()], [['Force shut down manually.']])));
        this.redis.sadd(this.key('GROUPS:FAILED'), this.task[1]);
        this.redis.sadd(this.key('BLOCKED'), this.task[1]);
        delete this.task;
      }
      this.redis.hdel(this.key('WORKERS'), this.id);
      workers.splice(workers.indexOf(this), 1);
      if (!(shutting_down || do_not_bubble)) {
        return shut_down();
      }
    };

    return Worker;

  })();

}).call(this);
